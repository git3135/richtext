package com.onpositive.richtexteditor.wikitext.parser;

import java.util.ArrayList;

import com.onpositive.richtext.model.BasePartition;
import com.onpositive.richtext.model.HRPartition;
import com.onpositive.richtext.model.ImagePartition;
import com.onpositive.richtext.model.LinkPartition;
import com.onpositive.richtext.model.RegionPartition;
import com.onpositive.richtext.model.meta.ITextDocument;
import com.onpositive.richtexteditor.io.LexEvent;
import com.onpositive.richtexteditor.io.html_scaner.EOFEvent;
import com.onpositive.richtexteditor.model.IFontStyleManager;
import com.onpositive.richtexteditor.wikitext.io.NewWikitextScanner;
import com.onpositive.richtexteditor.wikitext.io.WikitextLinesScanner;
import com.onpositive.richtexteditor.wikitext.io.WikitextTokenProvider;
import com.onpositive.richtexteditor.wikitext.partitions.CamelCasePartition;

/**
 * This class is responsible for handling events generated by
 * {@link NewWikitextScanner} and {@link WikitextLinesScanner} and constructing
 * document framework from them - list of partitions, indents, bullets etc.
 * 
 * @author Dmitry "32kda" Karpneko (4934)
 */
public class WikitextLexEventConsumer implements ILexEventConsumer {

	protected StringBuilder curTextStr = new StringBuilder();
	protected ArrayList<BasePartition> partitions = new ArrayList<BasePartition>();
	protected ITextDocument document;
	protected StringBuilder globalBuilder = new StringBuilder();
	protected String lastSeparateLineMarkup = "";

	protected boolean isBold = false;
	protected boolean isItalic = false;
	protected boolean isUnderlined = false;
	protected boolean isStrikethrough = false;
	protected boolean isSubscript = false;
	protected boolean isSuperscript = false;

	// protected boolean wasEmptyLineInserted = false;

	protected final String h1StyleString = "font-family:Times New Roman; font-size:24pt";
	protected final String h2StyleString = "font-family:Times New Roman; font-size:18pt";
	protected final String h3StyleString = "font-family:Times New Roman; font-size:14pt";
	protected final String h4StyleString = "font-family:Times New Roman; font-size:12pt";

	protected int headerState = 0;
	protected String curHref = "";
	protected StringBuilder curRegionText;
	protected boolean escapedLink = false;

	protected static final int INDENT_SHIFT_CONST = 0;

	protected static final String imgLoadErrorString = "Error loading ";

	public WikitextLexEventConsumer(ITextDocument document) {
		this.document = document;
	}

	public void handleLexEvent(LexEvent event) {
		if (event instanceof LineTextLexEvent) {

			LineTextLexEvent tagEvent = (LineTextLexEvent) event;
			int type = tagEvent.getType();
			WikitextLine line = tagEvent.getContextLine();
			if (type == -1)
				return;
			if (type == LineTextLexEvent.EOL) {
				handleEOL(event, line);
			} /*
			 * else if (tagEvent.getType() ==
			 * LineTextLexEvent.OPTIONAL_WHITESPACE) { if (curTextStr.length() >
			 * 0) { if
			 * (!Character.isWhitespace(curTextStr.charAt(curTextStr.length
			 * ()-1))) curTextStr.append(event.l); } else if
			 * (globalBuilder.length() > 0 &&
			 * !Character.isWhitespace(globalBuilder
			 * .charAt(globalBuilder.length()-1))) { curTextStr.append(event.l);
			 * } }
			 */else {
				if (event.text.length() > 0
						|| type != LineTextLexEvent.NONE_TYPE) {
					final BasePartition newPartition = getNewFontPartition(line);
					// newPartition.setLength(event.text.length());
					addIfCorrect(newPartition);
				}

				if (type == LineTextLexEvent.BOLD) {
					if (tagEvent.isDoNotInverse()) {
						if (isBold) {
							isBold = false;
						}
					} else {
						isBold = !isBold;
					}
				} else if (type == LineTextLexEvent.ITALIC) {
					if (tagEvent.isDoNotInverse()) {
						if (isItalic) {
							isItalic = false;
						}
					} else {
						isItalic = !isItalic;
					}
				} else if (type == LineTextLexEvent.BOLD_ITALIC) {
					isBold = !isBold;
					isItalic = !isItalic;
				} else if (type == LineTextLexEvent.UNDERLINED) {
					if (tagEvent.isDoNotInverse()) {
						if (isUnderlined) {
							isUnderlined = false;
						}
					} else {
						isUnderlined = !isUnderlined;
					}
				} else if (type == LineTextLexEvent.STRIKETHROUGH) {
					if (tagEvent.isDoNotInverse()) {
						if (isStrikethrough) {
							isStrikethrough = false;
						}
					} else {
						isStrikethrough = !isStrikethrough;
					}
				} else if (type == LineTextLexEvent.SUBSCRIPT) {
					if (tagEvent.isDoNotInverse()) {
						if (isSubscript) {
							isSubscript = false;
						}
					} else {
						isSubscript = !isSubscript;
					}
				} else if (type == LineTextLexEvent.SUPERSCRIPT) {
					if (tagEvent.isDoNotInverse()) {
						if (isSuperscript) {
							isSuperscript = false;
						}
					} else {
						isSuperscript = !isSuperscript;
					}
				} else if (type == LineTextLexEvent.IMAGE) {
					appendImage(tagEvent.text);
				} else if (type == LineTextLexEvent.LINK) {
					handleLink(tagEvent, line);
				} else if (type == LineTextLexEvent.NONE_TYPE) {
					appendText(event, line);
					/*
					 * if (wasBullet || wasNumber) endOfLineReached();
					 */
				} else if (type == LineTextLexEvent.MONOSPACE) {
					handleMonospace(event, line);
				} else if (type == WikitextLine.HEADER) {
					addIfCorrect(createHeaderPartition(line));
				} else if (type == LineTextLexEvent.REGION) {
					handleRegion(event.text);
				} else if (type == LineTextLexEvent.DEFLIST) {
					appendSpecialRegion(event.text,
							RegionPartition.DEFLIST_CONTENT_TYPE);
				} else if (type == LineTextLexEvent.TABLE) {
					appendSpecialRegion(event.text,
							RegionPartition.TABLE_CONTENT_TYPE);
				} else if (type == LineTextLexEvent.HR) {
					handleHR();
				} else if (type > LineTextLexEvent.MAX_TYPE) // Should be
																// handled
																// somewhere in
																// children
				{
					boolean handled = extraHandle((LineTextLexEvent) event,
							line);
					if (!handled) {
						appendText(event, line);
						System.err.println("Unknown parser event type " + type);
					}
				} else if (event.text.length() > 0) {
					appendText(event, line);
				}
			}
		} else if (event instanceof LineTextLexEvent) {
			handleTextEvent((LineTextLexEvent) event);
		} else if (event instanceof EOFEvent) {
			BasePartition partition = getNewFontPartition(null);
			addIfCorrect(partition);
		} else if (event.text.length() > 0) {
			appendText(event, null);
		}

	}

	/**
	 * Does extra handling for cuustom typed events (event.type >=
	 * {@link LineTextLexEvent#MAX_TYPE}) Empty here, intended to be overriden
	 * in subclasses when needed.
	 * 
	 * @param event
	 *            {@link LineTextLexEvent} to handle
	 * @param line
	 *            context {@link WikitextLine}
	 * @return Whether given event was successfully handled
	 */
	protected boolean extraHandle(LineTextLexEvent event, WikitextLine line) {
		return false;
	}

	protected void handleMonospace(LexEvent event, WikitextLine line) {
		curTextStr.append(event.text);
		BasePartition partition = getNewFontPartition(line);
		partition.setFontDataName(IFontStyleManager.FONT_MONOSPACE_NAME);
		addIfCorrect(partition);
		/*
		 * if (wasBullet || wasNumber) endOfLineReached();
		 */
	}

	protected void appendText(LexEvent event, WikitextLine line) {
		curTextStr.append(event.text);
		BasePartition partition = getNewFontPartition(line);
		addIfCorrect(partition);
	}

	protected void handleLink(LineTextLexEvent tagEvent, WikitextLine line) {
		if (tagEvent.text.startsWith("!")) {
			escapedLink = true;
			tagEvent.text = tagEvent.text.substring(1);
		}
		curHref = getCurHrefFromStr(tagEvent.text);
		int startIdx = tagEvent.text.indexOf(curHref) + curHref.length();
		int endIdx = tagEvent.text.lastIndexOf(']');
		if (endIdx == -1 || endIdx <= startIdx)
			endIdx = tagEvent.text.length();
		String content = tagEvent.text.substring(startIdx, endIdx).trim();
		if (content.trim().length() == 0)
			content = removePreffix(curHref);
		curTextStr.append(content);
		BasePartition partition = getNewFontPartition(line);
		addIfCorrect(partition);
	}

	protected void handleEOL(LexEvent event, WikitextLine line) {
		if (partitions.size() > 0
				&& partitions.get(partitions.size() - 1).requiresSingleLine()) // no
																				// need
																				// to
																				// add
																				// extra
																				// newline
			return;
		curTextStr.append(event.text);
		BasePartition partition = getNewFontPartition(line);
		addIfCorrect(partition);
		endOfLineReached();
	}

	protected void handleTextEvent(LineTextLexEvent event) {
		WikitextLine line = event.getContextLine();
		int type = line.getType();
		if (type == WikitextLine.HEADER) {
			addIfCorrect(createHeaderPartition(line));
			endOfLineReached();
		} else if (type == WikitextLine.REGION) {
			handleRegion(line.getText());
		} else if (type == WikitextLine.HR) {
			handleHR();
		}

	}

	protected BasePartition createHeaderPartition(WikitextLine line) {
		// TODO Auto-generated method stub
		return null;
	}

	/**
	 * Sets a data for header paritition, which is it's explicit id It's
	 * supposed, that event "calling" this function can only be thrown after a
	 * header markup, so we don't need to check whether there is a last
	 * partition and it's a header partition. All these must be OK already. If
	 * not, something is really wrong...
	 * 
	 * @param l
	 *            explicit id text
	 */
	protected void appendExplicitIdToLatestHeader(String l) {
		int last = partitions.size() - 1;
		if (l.startsWith("#"))
			l = l.substring(1);
		partitions.get(last).setData(l);
	}

	protected String extractBulletMarker(String l) {
		l = l.trim();
		final int lastIdx = l.lastIndexOf('.');
		if (lastIdx > 0)
			l = l.substring(0, lastIdx);
		return l;
	}

	protected int countLeftSpaces(String l) {
		int i = 0;
		for (; i < l.length() && l.charAt(i) == ' '; i++)
			;
		return i;
	}

	/**
	 * Inserts \n\r at the end of paragraph && does align & list style calcs, if
	 * needed
	 */
	protected void endOfLineReached() {
		final int length = curTextStr.length();
		int i = length - 1;
		while (i > 0 && curTextStr.charAt(i) == ' ')
			i--;
		if (i >= 0 && i < length - 1)
			curTextStr.delete(i + 1, length - 1);
		curTextStr.append("\r\n");
		//globalBuilder.append(curTextStr);
		//curTextStr=new StringBuilder();
	}

	protected void endOfLineReachedWithoutReset() {
		curTextStr.append("\r\n");
	}

	protected void addIfCorrect(BasePartition partition) {
		if (partition != null && partition.getLength() > 0)
			partitions.add(partition);
	}

	protected String getCurHrefFromStr(String l) {
		StringBuilder sb = new StringBuilder();
		int idx = 0;/*
					 * l.indexOf("wiki:"); if (idx == -1) idx =
					 * l.indexOf("http://"); if (idx == -1) { l = l.trim(); for
					 * (int i = 0; i < l.length(); i++) { if
					 * (Character.isWhitespace(l.charAt(i))) throw new
					 * RuntimeException("Wrong wikitext hyperlink - " + l); } if
					 * (l.length() == 0) throw new
					 * RuntimeException("Wrong wikitext hyperlink - " + l);
					 * return l; }
					 */
		for (int i = idx; i < l.length()
				&& !Character.isWhitespace(l.charAt(i)); i++)
			sb.append(l.charAt(i));
		return sb.toString();
	}

	protected String removePreffix(String l) {
		String str = WikitextTokenProvider.getInstance().getKeyword(
				WikitextTokenProvider.WIKI_LINK_PREFFIX);
		int idx = l.indexOf(str);
		if (idx == -1) {
			str = WikitextTokenProvider.getInstance().getKeyword(
					WikitextTokenProvider.ATTACHMENT_LINK_PREFFIX);
			idx = l.indexOf(str);
		}
		if (idx == -1) {
			str = WikitextTokenProvider.getInstance().getKeyword(
					WikitextTokenProvider.TICKET_LINK_PREFFIX);
			idx = l.indexOf(str);
		}
		if (idx == -1) {
			str = WikitextTokenProvider.getInstance().getKeyword(
					WikitextTokenProvider.COMMENT_LINK_PREFFIX);
			idx = l.indexOf(str);
		}
		if (idx >= 0) {
			StringBuilder sb = new StringBuilder();
			for (int i = idx + str.length(); i < l.length()
					&& !Character.isWhitespace(l.charAt(i)); i++)
				sb.append(l.charAt(i));
			return sb.toString();
		}

		return l;

	}

	/**
	 * @return the partitions
	 */
	public ArrayList<BasePartition> getPartitions() {
		return partitions;
	}

	public String getText() {
		return globalBuilder.toString();
	}

	/**
	 * used to get doc index to add partitions to doc's end 0 if doc contains no
	 * partitions, offset + length of last partition otherwise
	 */
	protected int getDocEndOffset() {
		int newOffset = 0; // TODO Maybe, possible to replace with
		// globalBuilder.length
		if (partitions.size() > 0)
			newOffset = partitions.get(partitions.size() - 1).getOffset()
					+ partitions.get(partitions.size() - 1).getLength();
		return newOffset;
	}

	protected void appendImage(String curSrc) {
		int idx1 = curSrc.lastIndexOf('(');
		int idx2 = curSrc.lastIndexOf(')');
		if (idx1 > 0 && idx2 > idx1)
			curSrc = curSrc.substring(idx1 + 1, idx2);
		int newOffset = getDocEndOffset();

		globalBuilder.append("?");
		partitions
				.add(new ImagePartition(document, newOffset, 1, null, curSrc));

	}

	protected void handleHR() {
		int newOffset = getDocEndOffset();

		/*
		 * partitions.add(new BasePartition(document, newOffset, 1));
		 * globalBuilder.append("\n"); newOffset++;
		 */

		String hrStr; // And here add new HR partition
		if (checkEolPresence())
			hrStr = "?\n";
		else {
			hrStr = "\n?\n";
		}
		HRPartition hrp = new HRPartition(document, newOffset, hrStr.length());
		partitions.add(hrp);
		globalBuilder.append(hrStr);
		resetStyleFlags();
	}

	protected void appendSpecialRegion(String lex, String contentType) {
		// if (!checkEolPresence())
		if (!(globalBuilder.length() == 0 && curTextStr.length() == 0)
				&& countNewlines() < 1)
			appendNewLinePartition();
		int newOffset = getDocEndOffset();
		String regionStr = "?\n"; // And here add new HR partition
		int i = lex.length() - 1;
		for (; i > 0 && Character.isWhitespace(lex.charAt(i)); i--)
			;
		lex = lex.substring(0, i + 1);
		RegionPartition partition = new RegionPartition(document, newOffset,
				regionStr.length(), contentType, lex);
		partitions.add(partition);
		globalBuilder.append(regionStr);
	}

	public void handleRegion(String lex) {		
		if (!(globalBuilder.length() == 0 && curTextStr.length() == 0)
				&& countNewlines() < 1)
			appendNewLinePartition();
		int newOffset = getDocEndOffset();
		String contentType = RegionPartition.PLAIN_TEXT_CONTENT_TYPE;
		int tpStart = 0;
		while (tpStart < lex.length()
				&& Character.isWhitespace(lex.charAt(tpStart)))
			tpStart++;
		int b = 0;
		for (int a = tpStart; a < lex.length(); a++) {
			if (Character.isWhitespace(lex.charAt(a))) {
				b = a;
				break;
			}
		}
		while (b < lex.length() && lex.charAt(b) == ' ')
			b++;
		if (b > tpStart) {
			String tp = lex.substring(tpStart, b);
			// lex = lex.replaceAll("\\r\\n","\n");

			if (tp.startsWith("#") && tp.length() > 1) {
				contentType = tp.trim();
				if (contentType.length() > 2) {
					if (!contentType.trim().equals("#!rst")) // TODO
					{
						while (b < lex.length()
								&& (lex.charAt(b) == '\r' || lex.charAt(b) == '\n'))
							b++;
					} else {
						// if (lex.charAt(b) == '\n')
						// b++;
					}
					lex = lex.substring(b, lex.length());
				} else
					contentType = RegionPartition.PLAIN_TEXT_CONTENT_TYPE;
			}
		}
		// else if (lex.startsWith("\n"))
		// lex = lex.substring(1);

		if (lex.startsWith("\r\n")) {
			lex = lex.substring(2);
		} else if (lex.startsWith("\n")) {
			lex = lex.substring(1);
		} else if (lex.startsWith("\r")) {
			lex = lex.substring(1);
		}

		String regionStr = "?\n"; // And here add new HR partition
		RegionPartition partition = new RegionPartition(document, newOffset,
				regionStr.length(), contentType, lex);
		partitions.add(partition);
		globalBuilder.append(regionStr);
		resetStyleFlags();
	}

	protected int countNewlines() {
		int cnt = 0;
		String s1 = curTextStr.toString().replaceAll("\\r\\n", "\n");
		s1 = s1.replaceAll("\\n\\r", "\n");
		if (s1.equals("\n\n"))
			return 2;
		if (s1.equals("\n"))
			cnt++;

		String s2 = globalBuilder.toString().replaceAll("\\r\\n", "\n");
		s2 = s2.replaceAll("\\n\\r", "\n");
		int i = s2.length() - 1;
		while (i > 0 && s2.charAt(i) == '\n') {
			cnt++;
			i--;
		}
		return cnt;
	}

	protected void appendNewLinePartition() {
		endOfLineReached();
		BasePartition partition = getNewFontPartition(null);
		addIfCorrect(partition);
		
	}

	protected boolean checkEolPresence() {
		// boolean b = !curTextStr.equals(" ")
		// && !curTextStr.equals("\t");
		if (curTextStr.length() > 0)
		// TODO CHECK ME
		{
			if (curTextStr.charAt(curTextStr.length() - 1) == '\n'
					|| curTextStr.charAt(curTextStr.length() - 1) == '\r') {
				return true;
			}
		} else if (globalBuilder.length() > 0
				&& (globalBuilder.charAt(globalBuilder.length() - 1) == '\n' || globalBuilder
						.charAt(globalBuilder.length() - 1) == '\r'))
			return true;
		if (globalBuilder.toString().trim().equals("")
				&& curTextStr.toString().trim().equals(""))
			return true;
		return globalBuilder.length() == 0 && curTextStr.length() == 0;
	}

	protected void insertNewLineWithAfterListCheck() {
		if (!checkEolPresence() || isAfterSpecialString())
			endOfLineReached();
	}

	protected void insertNewLineIfNeeded() {
		if (!checkEolPresence())
			endOfLineReached();
	}

	protected boolean isAfterSpecialString() {
		if (partitions.size() > 0) {
			final BasePartition partition = partitions
					.get(partitions.size() - 1);
			if (partition instanceof RegionPartition)
				return true;
		}
		return false;
	}

	protected BasePartition getNewFontPartition(WikitextLine context) {
		// String addAfterPartitionStr = ""; // used for adding some symbols
		// after
		// current partition
		int newOffset = 0;
		if (partitions.size() > 0)
			newOffset = partitions.get(partitions.size() - 1).getOffset()
					+ partitions.get(partitions.size() - 1).getLength();
		BasePartition newPartition;
		if (!curHref.equals("")) {
			/*
			 * if (curTextStr.length() > 0 &&
			 * !Character.isWhitespace(curTextStr.charAt(curTextStr .length() -
			 * 1))) addAfterPartitionStr = " ";
			 */
			if (curTextStr.toString().equals(curHref)
					&& WikitextTokenProvider.isCamelCaseWord(curHref)) {
				newPartition = new CamelCasePartition(document, newOffset,
						curTextStr.length());
				((CamelCasePartition) newPartition).setUrl(curHref); // We need
																		// this,
																		// because
																		// we
																		// can
																		// be
																		// disconnected
																		// from
																		// document
																		// when
																		// doing
																		// some
																		// preprocessing
				if (escapedLink)
					((CamelCasePartition) newPartition)
							.setStyle(CamelCasePartition.ESCAPED);
			} else
				newPartition = new LinkPartition(document, newOffset,
						curTextStr.length());
			((LinkPartition) newPartition).setUrl(curHref);
			curHref = "";
			escapedLink = false;
		} else
			newPartition = new BasePartition(document, newOffset,
					curTextStr.length());
		// newPartition.setRefreshVisibleState(false); // Don't update anything;
		// Partition is still under
		// construction
		newPartition.setBold(isBold);
		newPartition.setItalic(isItalic);
		newPartition.setUnderlined(isUnderlined);
		newPartition.setStrikethrough(isStrikethrough);
		newPartition.setSub(isSubscript);
		newPartition.setSup(isSuperscript);
		newPartition.setStrikethrough(isStrikethrough);
		if (context instanceof HeaderLine)
			newPartition.setFontDataName(getFontDataName((HeaderLine) context));
		String resStr = curTextStr.toString();
		final int gbLength = globalBuilder.length();
		if (gbLength > 0 && globalBuilder.charAt(gbLength - 1) == ' '
				&& resStr.length() > 0
				&& (resStr.charAt(0) == ' ' || resStr.charAt(0) == '\t'))
			resStr = resStr.substring(1);

		/*
		 * if (!trimWhiteSpaces && str.charAt(i) == '\n') endOfLineReached();
		 */

		globalBuilder.append(resStr);
		newPartition.setLength(resStr.length());
		// curTextStr = new StringBuilder(addAfterPartitionStr);
		curTextStr = new StringBuilder();
		return newPartition;
	}

	protected String getFontDataName(HeaderLine context) {
		if (context.getHeaderLevel() == 1)
			return IFontStyleManager.FONT_H1_NAME;
		if (context.getHeaderLevel() == 2)
			return IFontStyleManager.FONT_H2_NAME;
		if (context.getHeaderLevel() == 3)
			return IFontStyleManager.FONT_H3_NAME;
		if (context.getHeaderLevel() == 4)
			return IFontStyleManager.FONT_H4_NAME;
		if (context.getHeaderLevel() == 5)
			return IFontStyleManager.FONT_H5_NAME;
		if (context.getHeaderLevel() == 6)
			return IFontStyleManager.FONT_H6_NAME;
		return IFontStyleManager.NORMAL_FONT_NAME;
	}

	protected void resetStyleFlags() {
		isBold = false;
		isItalic = false;
		isUnderlined = false;
		isStrikethrough = false;
	}

}
