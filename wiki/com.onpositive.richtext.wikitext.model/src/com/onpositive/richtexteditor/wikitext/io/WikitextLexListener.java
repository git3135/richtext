package com.onpositive.richtexteditor.wikitext.io;

import java.util.ArrayList;
import java.util.HashMap;


import com.onpositive.richtext.model.BasePartition;
import com.onpositive.richtext.model.BasePartitionLayer;
import com.onpositive.richtext.model.HRPartition;
import com.onpositive.richtext.model.ImagePartition;
import com.onpositive.richtext.model.LinkPartition;
import com.onpositive.richtext.model.RegionPartition;
import com.onpositive.richtext.model.meta.BulletFactory;
import com.onpositive.richtext.model.meta.ITextDocument;
import com.onpositive.richtexteditor.io.LexEvent;
import com.onpositive.richtexteditor.io.html_scaner.EOFEvent;
import com.onpositive.richtexteditor.io.html_scaner.ILexListener;
import com.onpositive.richtexteditor.model.IFontStyleManager;
import com.onpositive.richtexteditor.model.RichTextEditorConstants;
import com.onpositive.richtexteditor.wikitext.partitions.CamelCasePartition;

/**
 * This class is responsible for handling events generated by {@link NewWikitextScanner} and {@link WikitextLinesScanner}
 * and constructing document framework from them - list of partitions, indents, bullets etc. 
 * @author Dmitry "32kda" Karpneko (4934) 
 */
public class WikitextLexListener implements ILexListener {

	protected StringBuilder curTextStr = new StringBuilder();
	protected ArrayList<BasePartition> partitions = new ArrayList<BasePartition>();
	protected ArrayList<Integer> lineAligns = new ArrayList<Integer>();
	protected ArrayList<Integer> lineBullets = new ArrayList<Integer>();
	protected ArrayList<Integer> lineBulletTypes = new ArrayList<Integer>();
	protected ArrayList<Integer> lineIndents = new ArrayList<Integer>();
	protected HashMap<Integer, Integer> lists = new HashMap<Integer, Integer>();
	protected HashMap<Integer, String> numberedListStarts = new HashMap<Integer, String>();
	protected ITextDocument document;
	protected StringBuilder globalBuilder = new StringBuilder();
	protected String lastSeparateLineMarkup = "";
	
	protected boolean isBold = false;
	protected boolean isItalic = false;
	protected boolean isUnderlined = false;
	protected boolean isStrikethrough = false;
	protected boolean isSubscript = false;
	protected boolean isSuperscript = false;

	protected boolean wasBullet = false; // There was a bullet in the beginning
	// of the line
	protected boolean wasNumber = false;
	
	//protected boolean wasEmptyLineInserted = false;

	protected final String h1StyleString = "font-family:Times New Roman; font-size:24pt";
	protected final String h2StyleString = "font-family:Times New Roman; font-size:18pt";
	protected final String h3StyleString = "font-family:Times New Roman; font-size:14pt";
	protected final String h4StyleString = "font-family:Times New Roman; font-size:12pt";

	protected int currentNumberedListValue = 1;

	protected int numberedListLevel = 0;
	protected int currentIndent = 0;

	protected String lastParsedBulletStr = "";

	protected int headerState = 0;
	protected String curHref = "";
	protected StringBuilder curRegionText;
	protected boolean escapedLink = false;

	protected static final int NONE_HEADER = 0;
	protected static final int IS_HEADER1 = 1;
	protected static final int IS_HEADER2 = 2;
	protected static final int IS_HEADER3 = 3;
	protected static final int IS_HEADER4 = 4;
	protected static final int IS_HEADER5 = 5;
	protected static final int IS_HEADER6 = 6;

	protected static final int INDENT_SHIFT_CONST = 0;

	protected static final String imgLoadErrorString = "Error loading ";
	
	public WikitextLexListener(ITextDocument document) {
		this.document = document;
	}

	public void handleLexEvent(LexEvent event) {
		if (event instanceof WikitextLexEvent) {

			WikitextLexEvent tagEvent = (WikitextLexEvent) event;
			int type = tagEvent.getType();
			if (type == -1)
				return;
			if (tagEvent.getType() == WikitextLexEvent.NUMBERED_LIST) {
				resetStyleFlags();
				insertNewLineIfNeeded();
				wasNumber = true;
				lastParsedBulletStr = extractBulletMarker(tagEvent.text);
				
				//currentIndent = countLeftSpaces(tagEvent.l);
				clearAllGreater(currentIndent);
				Integer numObj = lists.get(currentIndent);
				if (numObj == null
						|| numObj.intValue() == BulletFactory.BULLETED_LIST) {
					currentNumberedListValue++;
					lists.put(currentIndent, currentNumberedListValue);
				}
				
				if (numberedListLevel == 0)					
				{
					numberedListLevel++;
					if (!lastParsedBulletStr.equals("1") && !lastParsedBulletStr.equals("a") 
						&&!lastParsedBulletStr.equals("i"))
					{
						if (numObj == null
								|| numObj.intValue() == BulletFactory.BULLETED_LIST) {
							numberedListStarts.put(currentNumberedListValue, lastParsedBulletStr);
						}
					}
				}
				checkPreviousList();

			} else if (tagEvent.getType() == WikitextLexEvent.BULLETED_LIST) {
				resetStyleFlags();
				insertNewLineIfNeeded();
				wasBullet = true;
				// currentIndent = countLeftSpaces(tagEvent.l);
				clearAllGreater(currentIndent);
				lists.put(currentIndent, BulletFactory.BULLETED_LIST);
				checkPreviousList();
			} else if (tagEvent.getType() == WikitextLexEvent.INDENT) {
				if (checkEolPresence())
				{
					currentIndent = tagEvent.text.length() - INDENT_SHIFT_CONST;
					clearAllGreater(currentIndent);
					if (wasNumber) //That means, that current indent is indent for line, which is part of current list item, e.g.
						lists.put(currentIndent, BulletFactory.BULLETED_LIST);            // 1. aaaa
					else if (wasBullet)													  //    aaa aaa aaa <- we are here, but this line should be merged with previous due to it's indent
						lists.put(currentIndent, BulletFactory.BULLETED_LIST);
				}
				else if (lastSeparateLineMarkup.length() > 0)
				{
					if (tagEvent.text.length() >= lastSeparateLineMarkup.length())
						curTextStr.append(" ");
					else
					{
						lastSeparateLineMarkup = "";
						insertNewLineIfNeeded();
					}
				}
			} else if (tagEvent.getType() == WikitextLexEvent.RESET_STYLE_FLAGS) {
				
				resetStyleFlags();
			} else if (tagEvent.getType() == WikitextLexEvent.EOL_REACHED) {

				curTextStr.append(event.text);
				BasePartition partition = getNewFontPartition();
				addIfCorrect(partition);

				insertNewLineIfNeeded();
			} else if (tagEvent.getType() == WikitextLexEvent.ADDITIONAL_NEWLINE) { //Should add additional line, if between lists
				if (!checkEolPresence()/* || (lineBullets.size() > 0 && lineBullets.get(lineBullets.size() - 1) > BulletFactory.NONE_LIST_CONST)*/)
				{
					curTextStr.append(event.text);
					//endOfLineReached();
					BasePartition partition = getNewFontPartition();
					addIfCorrect(partition);
					resetStyleFlags();
					insertNewLineWithAfterListCheck();
				}
			} else if (tagEvent.getType() == WikitextLexEvent.ADDITIONAL_NEWLINE) {
				curTextStr.append(event.text);
				BasePartition partition = getNewFontPartition();
				addIfCorrect(partition);
				resetStyleFlags();
				endOfLineReached();				
			} else if (tagEvent.getType() == WikitextLexEvent.OPTIONAL_WHITESPACE) { 
				if (curTextStr.length() > 0)
				{
					if (!Character.isWhitespace(curTextStr.charAt(curTextStr.length()-1)))
						curTextStr.append(event.text);
				}
				else if (globalBuilder.length() > 0 && !Character.isWhitespace(globalBuilder.charAt(globalBuilder.length()-1)))
				{
					curTextStr.append(event.text);
				}
			} else if (tagEvent.getType() == WikitextLexEvent.EXPLICIT_ID) { //Should add additional line, if between lists
				appendExplicitIdToLatestHeader(tagEvent.text);
			} else {
				if (event.text.length() > 0
						|| tagEvent.getType() != WikitextLexEvent.NONE_TYPE) {
					final BasePartition newPartition = getNewFontPartition();
					addIfCorrect(newPartition);
				}

				if (tagEvent.getType() == WikitextLexEvent.BOLD) {
					isBold = !isBold;
				} else if (tagEvent.getType() == WikitextLexEvent.ITALIC) {
					isItalic = !isItalic;
				} else if (tagEvent.getType() == WikitextLexEvent.BOLD_ITALIC) {
					isBold = !isBold;
					isItalic = !isItalic;
				} else if (tagEvent.getType() == WikitextLexEvent.UNDERLINED) {
					isUnderlined = !isUnderlined;
				} else if (tagEvent.getType() == WikitextLexEvent.STRIKETHROUGH) {
					isStrikethrough = !isStrikethrough;
				} else if (tagEvent.getType() == WikitextLexEvent.SUBSCRIPT) {
					isSubscript = !isSubscript;
				} else if (tagEvent.getType() == WikitextLexEvent.SUPERSCRIPT) {
					isSuperscript = !isSuperscript;
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER1_OPEN) {
					headerState = IS_HEADER1;
					currentIndent = 0;
					insertNewLineIfNeeded();
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER2_OPEN) {
					headerState = IS_HEADER2;
					currentIndent = 0;
					insertNewLineIfNeeded();
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER3_OPEN) {
					headerState = IS_HEADER3;
					currentIndent = 0;
					insertNewLineIfNeeded();
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER4_OPEN) {
					headerState = IS_HEADER4;
					currentIndent = 0;
					insertNewLineIfNeeded();
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER5_OPEN) {
					headerState = IS_HEADER5;
					currentIndent = 0;
					insertNewLineIfNeeded();
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER6_OPEN) {
					headerState = IS_HEADER6;
					currentIndent = 0;
					insertNewLineIfNeeded();
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.BR) {
					endOfLineReached();
				} else if (tagEvent.getType() == WikitextLexEvent.HR) {
					appendHR();
					resetStyleFlags();					
				} else if (tagEvent.getType() == WikitextLexEvent.REGION_START)	{
					curRegionText = new StringBuilder();
				}
				else if (tagEvent.getType() == WikitextLexEvent.REGION_STRING)	{
					curRegionText.append(tagEvent.text);
					curRegionText.append('\n');
				}
				else if (tagEvent.getType() == WikitextLexEvent.REGION_END)	{
					appendRegion(curRegionText.toString());
					resetStyleFlags();
				}
				else if (tagEvent.getType() == WikitextLexEvent.TABLE_END)	{
					appendSpecialRegion(curRegionText.toString(), RegionPartition.TABLE_CONTENT_TYPE);
					resetStyleFlags();
				}
				else if (tagEvent.getType() == WikitextLexEvent.DEFLIST_END)	{
					appendSpecialRegion(curRegionText.toString(), RegionPartition.DEFLIST_CONTENT_TYPE);
					resetStyleFlags();
				}
				else if (tagEvent.getType() == WikitextLexEvent.SIMPLE_REGION) {
					appendRegion(tagEvent.text);
					resetStyleFlags();
				} else if (tagEvent.getType() == WikitextLexEvent.HEADER_CLOSE) {
					headerState = 0;
					endOfLineReached();
					resetStyleFlags();

				} else if (tagEvent.getType() == WikitextLexEvent.IMAGE) {
					appendImage(tagEvent.text);
				} else if (tagEvent.getType() == WikitextLexEvent.LINK) {
					if (tagEvent.text.startsWith("!"))
					{
						escapedLink = true;
						tagEvent.text = tagEvent.text.substring(1);
					}
					curHref = getCurHrefFromStr(tagEvent.text);
					int startIdx = tagEvent.text.indexOf(curHref)
							+ curHref.length();
					int endIdx = tagEvent.text.lastIndexOf(']');
					if (endIdx == -1)
						endIdx = tagEvent.text.length();
					String content = tagEvent.text.substring(startIdx, endIdx)
							.trim();
					if (content.trim().length() == 0)
						content = removePreffix(curHref);
					curTextStr.append(content);
					BasePartition partition = getNewFontPartition();
					addIfCorrect(partition);
				}

				else if (tagEvent.getType() == WikitextLexEvent.EOL_REACHED) {
					curTextStr.append(event.text);
					BasePartition partition = getNewFontPartition();
					addIfCorrect(partition);
					endOfLineReached();
				} else if (tagEvent.getType() == WikitextLexEvent.SEPARATE_LINE) {
					resetStyleFlags();
					insertNewLineIfNeeded();
					curTextStr.append(tagEvent.text);
					lastSeparateLineMarkup = tagEvent.text;
				} else if (tagEvent.getType() == WikitextLexEvent.NONE_TYPE) {
					curTextStr.append(event.text);
					BasePartition partition = getNewFontPartition();
					addIfCorrect(partition);
					/*
					 * if (wasBullet || wasNumber) endOfLineReached();
					 */
				} else if (tagEvent.getType() == WikitextLexEvent.MONOSPACE) {
					curTextStr.append(event.text);
					BasePartition partition = getNewFontPartition();
					partition
							.setFontDataName(IFontStyleManager.FONT_MONOSPACE_NAME);
					addIfCorrect(partition);
					/*
					 * if (wasBullet || wasNumber) endOfLineReached();
					 */
				} else if (event.text.length() > 0) {
					curTextStr.append(event.text);
					BasePartition partition = getNewFontPartition();
					addIfCorrect(partition);
				}
			}
		} else if (event instanceof EOFEvent) {
			BasePartition partition = getNewFontPartition();
			addIfCorrect(partition);
			setAlignAndBulletStates(true);
			normalizeListIndents();
		} else if (event.text.length() > 0) {
			curTextStr.append(event.text);
			BasePartition partition = getNewFontPartition();
			addIfCorrect(partition);
		}

	}

	/**
	 * Sets a data for header paritition, which is it's explicit id 
	 * It's supposed, that event "calling" this function can only be thrown after a header markup, so we don't need to
	 * check whether there is a last partition and it's a header partition.
	 * All these must be OK already.
	 * If not, something is really wrong... 
	 * @param l explicit id text 
	 */
	protected void appendExplicitIdToLatestHeader(String l)
	{
		int last = partitions.size() - 1;
		if (l.startsWith("#"))
			l = l.substring(1);
		partitions.get(last).setData(l);
	}

	protected void normalizeListIndents() {
		for (int i = 1; i < lineBullets.size(); i++) {
			int bullet2 = lineBullets.get(i);
			if (bullet2 > BulletFactory.NONE_LIST_CONST) {
				int indent2 = lineIndents.get(i);
				int bullet1 = lineBullets.get(i - 1);
				int indent1 = lineIndents.get(i - 1);

				if (indent2 > indent1 + 1
						&& bullet1 > BulletFactory.NONE_LIST_CONST) {
					int oldIndent2 = indent2;
					indent2 = indent1 + 1;
					int j = i;
					for (; lineBullets.get(j) > BulletFactory.NONE_LIST_CONST
							&& lineIndents.get(j) >= oldIndent2; j++)
					{
						int curIndent = lineIndents.get(j); 
						if (curIndent == oldIndent2)
						{
							lineIndents.set(j, indent2);
						}
						
					//i = j - 1;
					}
				}
				else if (bullet1 == BulletFactory.NONE_LIST_CONST && indent2 > 0) //List begins with indent different from 0
				{
					for (int j = i; j < lineBullets.size() && lineBullets.get(j) != BulletFactory.NONE_LIST_CONST; j++)
					{
						lineIndents.set(j, lineIndents.get(j) - indent2);
					}
				}
				
			}
		}
	}

	protected String extractBulletMarker(String l) {
		l = l.trim();
		final int lastIdx = l.lastIndexOf('.');
		if (lastIdx > 0)
			l = l.substring(0, lastIdx);
		return l;
	}

	protected int countLeftSpaces(String l) {
		int i = 0;
		for (; i < l.length() && l.charAt(i) == ' '; i++)
			;
		return i;
	}

	protected void clearAllGreater(int currentIndent) {
		currentIndent++;
		while (lists.get(currentIndent) != null) {
			lists.remove(currentIndent);
			currentIndent++;
		}
	}

	/**
	 * Inserts \n\r at the end of paragraph && does align & list style calcs, if
	 * needed
	 */
	protected void endOfLineReached() {
		final int length = curTextStr.length();
		int i = length - 1;
		while (i > 0 && curTextStr.charAt(i) == ' ')
			i--;
		if (i >= 0 && i < length - 1)
			curTextStr.delete(i + 1, length - 1);
		curTextStr.append("\r\n");
		setAlignAndBulletStates(true);
	}

	protected void endOfLineReachedWithoutReset() {
		curTextStr.append("\r\n");
		setAlignAndBulletStates(false);
	}

	protected void addIfCorrect(BasePartition partition) {
		if (partition != null && partition.getLength() > 0)
			partitions.add(partition);
	}

	protected String getCurHrefFromStr(String l) {
		StringBuilder sb = new StringBuilder();
		int idx = 0;/*
					 * l.indexOf("wiki:"); if (idx == -1) idx =
					 * l.indexOf("http://"); if (idx == -1) { l = l.trim(); for
					 * (int i = 0; i < l.length(); i++) { if
					 * (Character.isWhitespace(l.charAt(i))) throw new
					 * RuntimeException("Wrong wikitext hyperlink - " + l); } if
					 * (l.length() == 0) throw new
					 * RuntimeException("Wrong wikitext hyperlink - " + l);
					 * return l; }
					 */
		for (int i = idx; i < l.length()
				&& !Character.isWhitespace(l.charAt(i)); i++)
			sb.append(l.charAt(i));
		return sb.toString();
	}

	protected String removePreffix(String l) {		
		String str = WikitextTokenProvider.getInstance().getKeyword(WikitextTokenProvider.WIKI_LINK_PREFFIX);
		int idx = l.indexOf(str);
		if (idx == -1) 
		{
			str = WikitextTokenProvider.getInstance().getKeyword(WikitextTokenProvider.ATTACHMENT_LINK_PREFFIX);
			idx = l.indexOf(str);
		}
		if (idx == -1) 
		{
			str = WikitextTokenProvider.getInstance().getKeyword(WikitextTokenProvider.TICKET_LINK_PREFFIX);
			idx = l.indexOf(str);
		}
		if (idx == -1) 
		{
			str = WikitextTokenProvider.getInstance().getKeyword(WikitextTokenProvider.COMMENT_LINK_PREFFIX);
			idx = l.indexOf(str);
		}
		if (idx >= 0) {
			StringBuilder sb = new StringBuilder();
			for (int i = idx + str.length(); i < l.length()
					&& !Character.isWhitespace(l.charAt(i)); i++)
				sb.append(l.charAt(i));
			return sb.toString();
		}
		
		return l;

	}

	/**
	 * @return the partitions
	 */
	public ArrayList<BasePartition> getPartitions() {
		return partitions;
	}

	/**
	 * @return the lineAligns
	 */
	public ArrayList<Integer> getLineAligns() {
		return lineAligns;
	}

	/**
	 * @return the lineBullets
	 */
	public ArrayList<Integer> getLineBullets() {
		return lineBullets;
	}

	/**
	 * @return the lineIndents
	 */
	public ArrayList<Integer> getLineIndents() {
		return lineIndents;
	}

	/**
	 * @return the lineBulletTypes
	 */
	public ArrayList<Integer> getLineBulletTypes() {
		return lineBulletTypes;
	}

	public String getText() {
		return globalBuilder.toString();
	}

	protected void setAlignAndBulletStates(boolean reset) {
		if ((wasBullet || wasNumber) && lineBullets.size() > 0)
			checkPreviousList();
		if (wasBullet) {
			lineBullets.add(BulletFactory.BULLETED_LIST);
			lineBulletTypes.add(BulletFactory.NONE_LIST_CONST);
			if (reset)
				wasBullet = false;
		} else if (wasNumber) {
			lineBullets.add(lists.get(currentIndent));
			if (lastParsedBulletStr.length() > 0) {
				if (Character.isDigit(lastParsedBulletStr.charAt(0)))
					lineBulletTypes.add(BulletFactory.SIMPLE_NUMBERED_LIST);
				else if (lastParsedBulletStr.charAt(0) == 'a')
					lineBulletTypes.add(BulletFactory.LETTERS_NUMBERED_LIST);
				else if (lastParsedBulletStr.charAt(0) == 'i')
					lineBulletTypes.add(BulletFactory.ROMAN_NUMBERED_LIST);
				else {
					lineBulletTypes.add(BulletFactory.SIMPLE_NUMBERED_LIST);
//					Activator.getDefault().getLog().log(
//							new Status(Status.ERROR, Activator.PLUGIN_ID,
//									"Invalid numbered list preffix: "
//											+ lastParsedBulletStr));
				}
			}
			lastParsedBulletStr = "";
			if (reset)
				wasNumber = false;
		} else {
			if (numberedListLevel > 0 && reset) {
				numberedListLevel--;
				currentNumberedListValue++;
			}
			lineBullets.add(BulletFactory.NONE_LIST_CONST);
			lineBulletTypes.add(BulletFactory.NONE_LIST_CONST);
		}
		lineAligns.add(RichTextEditorConstants.LEFT_ALIGN);
		//lineIndents.add(currentIndent);
		if (lineBullets.get(lineBullets.size() - 1) == BulletFactory.NONE_LIST_CONST)
			lineIndents.add(currentIndent);
		else
			lineIndents.add(currentIndent - 1);
		if (reset)
			currentIndent = 0;
		
	}

	protected void checkPreviousList()
	{	 
		int i = lineBullets.size() - 1;
		for (; i >= 0 && lineBullets.get(i) != BulletFactory.NONE_LIST_CONST; i--)
		{
			if (currentIndent - 1 >= lineIndents.get(i))
				return;
		}
		if (i < 0)
			return;
		int j = lineBullets.size() - 1;
		if (j > i)
		{
			i++;
			int delta = lineIndents.get(i);
			for (; i <= j; i++)
			{
				lineIndents.set(i, lineIndents.get(i) - delta);
			}
			globalBuilder.append("\r\n");
			int newOffset = 0;
			if (partitions.size() > 0)
				newOffset = partitions.get(partitions.size() - 1).getOffset()
						+ partitions.get(partitions.size() - 1).getLength();
			addIfCorrect(new BasePartition(document, newOffset, 2));
			addEmptyLineValues();
		}
		
	}

	protected void addEmptyLineValues()
	{
		lineIndents.add(0);
		lineBullets.add(BulletFactory.NONE_LIST_CONST);
		lineAligns.add(RichTextEditorConstants.LEFT_ALIGN);
		lineBulletTypes.add(BulletFactory.NONE_LIST_CONST);
	}

	/**
	 * used to get doc index to add partitions to doc's end 0 if doc contains no
	 * partitions, offset + length of last partition otherwise
	 */
	protected int getDocEndOffset() {
		int newOffset = 0; // TODO Maybe, possible to replace with
		// globalBuilder.length
		if (partitions.size() > 0)
			newOffset = partitions.get(partitions.size() - 1).getOffset()
					+ partitions.get(partitions.size() - 1).getLength();
		return newOffset;
	}

	protected void appendImage(String curSrc) {
		int idx1 = curSrc.lastIndexOf('(');
		int idx2 = curSrc.lastIndexOf(')');
		if (idx1 > 0 && idx2 > idx1)
			curSrc = curSrc.substring(idx1 + 1, idx2);
		int newOffset = getDocEndOffset();
		
		globalBuilder.append("?");		
		partitions.add(new ImagePartition(document, newOffset, 1, null, curSrc));

	}	

	protected void appendHR() {
		int newOffset = getDocEndOffset();

		/*
		 * partitions.add(new BasePartition(document, newOffset, 1));
		 * globalBuilder.append("\n"); newOffset++;
		 */

		String hrStr; // And here add new HR partition
		if (checkEolPresence())
			hrStr = "?\n";
		else {
			hrStr = "\n?\n";
			setAlignAndBulletStates(true);
		}
		HRPartition hrp = new HRPartition(document, newOffset, hrStr.length());
		partitions.add(hrp);
		globalBuilder.append(hrStr);
		// -----------------For 2 newlines-----------------------
		lineAligns.add(RichTextEditorConstants.LEFT_ALIGN);
		lineIndents.add(0);
		lineBullets.add(BulletFactory.NONE_LIST_CONST);
		lineBulletTypes.add(BulletFactory.NONE_LIST_CONST);
	}
	
	protected void appendSpecialRegion(String lex, String contentType) {
		int regionIndent = currentIndent;
		if (contentType.equals(RegionPartition.DEFLIST_CONTENT_TYPE))
		{
			currentIndent = 0;
			regionIndent = 0;
		}
		// if (!checkEolPresence())
		if (!(globalBuilder.length() == 0 && curTextStr.length() == 0)
			&& countNewlines() < 1) appendNewLinePartition();
		int newOffset = getDocEndOffset();
		String regionStr = "?\n"; // And here add new HR partition
		int i = lex.length() - 1;
		for (; i > 0 && Character.isWhitespace(lex.charAt(i)); i--);
		lex = lex.substring(0, i + 1);
		RegionPartition partition = new RegionPartition(document, newOffset,
				regionStr.length(), contentType, lex);
		partitions.add(partition);
		globalBuilder.append(regionStr);
		// -----------------For 2 newlines-----------------------
		lineAligns.add(RichTextEditorConstants.LEFT_ALIGN);
		lineIndents.add(regionIndent);
		lineBullets.add(BulletFactory.NONE_LIST_CONST);
		lineBulletTypes.add(BulletFactory.NONE_LIST_CONST);
	}

	protected void appendRegion(String lex) {
		int regionIndent = currentIndent;
		// currentIndent = 0;
		// if (!checkEolPresence())
		if (!(globalBuilder.length() == 0 && curTextStr.length() == 0)
			&& countNewlines() < 1) appendNewLinePartition();
		int newOffset = getDocEndOffset();
		//lex = lex.trim();
		/*int start = lex.indexOf(REGION_START_STR);
		if (start == 0) {
			lex = lex
					.substring(start + REGION_START_STR.length(), lex.length());
		}
		int end = lex.lastIndexOf(REGION_END_STR);
		if (end == lex.length() - REGION_END_STR.length()) {
			lex = lex.substring(0, end);
		}*/
		String contentType = RegionPartition.PLAIN_TEXT_CONTENT_TYPE;
		// lex = lex.trim();
		int tpStart = 0;
		while (tpStart < lex.length() && Character.isWhitespace(lex.charAt(tpStart)))
			tpStart++;
		int b = 0;
		for (int a = tpStart; a < lex.length(); a++) {
			if (Character.isWhitespace(lex.charAt(a))) {
				b = a;
				break;
			}
		}
		while (b < lex.length() && lex.charAt(b) == ' ')
			b++;
		if (b > tpStart)
		{
			String tp = lex.substring(tpStart, b);
			// lex = lex.replaceAll("\\r\\n","\n");
	
			if (tp.startsWith("#") && tp.length() > 1) {
				contentType = tp.trim();
				if (contentType.length() > 2)
				{
					if (!contentType.trim().equals("#!rst")) // TODO
					{
						while (b < lex.length()
								&& (lex.charAt(b) == '\r' || lex.charAt(b) == '\n'))
							b++;
					} else {
						// if (lex.charAt(b) == '\n')
						// b++;
					}
					lex = lex.substring(b, lex.length());
				}
				else
					contentType = RegionPartition.PLAIN_TEXT_CONTENT_TYPE;
			}
		}
		// else if (lex.startsWith("\n"))
		// lex = lex.substring(1);

		if (lex.startsWith("\r\n")) {
			lex = lex.substring(2);
		} else if (lex.startsWith("\n")) {
			lex = lex.substring(1);
		} else if (lex.startsWith("\r")) {
			lex = lex.substring(1);
		}

		String regionStr = "?\n"; // And here add new HR partition
		RegionPartition partition = new RegionPartition(document, newOffset,
				regionStr.length(), contentType, lex);
		partitions.add(partition);
		globalBuilder.append(regionStr);
		// -----------------For 2 newlines-----------------------
		lineAligns.add(RichTextEditorConstants.LEFT_ALIGN);
		lineIndents.add(regionIndent);
		lineBullets.add(BulletFactory.NONE_LIST_CONST);
		lineBulletTypes.add(BulletFactory.NONE_LIST_CONST);
		/*
		 * lineAligns.add(RichTextEditorConstants.LEFT_ALIGN);
		 * lineBullets.add(BulletFactory.NONE_LIST_CONST);
		 */
	}

	protected int countNewlines()
	{
		int cnt = 0;
		String s1 = curTextStr.toString().replaceAll("\\r\\n","\n");
		s1 = s1.replaceAll("\\n\\r","\n");
		if (s1.equals("\n\n")) return 2;
		if (s1.equals("\n")) cnt++;
		
		String s2 = globalBuilder.toString().replaceAll("\\r\\n","\n");
		s2 = s2.replaceAll("\\n\\r","\n");
		int i = s2.length() - 1;
		while (i > 0 && s2.charAt(i) == '\n')
		{
			cnt++;
			i--;
		}
		return cnt;
	}

	protected void appendNewLinePartition() {
		endOfLineReached();
		BasePartition partition = getNewFontPartition();
		addIfCorrect(partition);
	}
	
	protected boolean checkEolPresence() {
//		boolean b = !curTextStr.equals(" ")
//						&& !curTextStr.equals("\t");
		if (curTextStr.length() > 0 ) 
		//TODO CHECK ME
		{
			if (curTextStr.charAt(curTextStr.length() - 1) == '\n'
					|| curTextStr.charAt(curTextStr.length() - 1) == '\r') {
				return true;
			}
		} else if (globalBuilder.length() > 0
				&& (globalBuilder.charAt(globalBuilder.length() - 1) == '\n' || globalBuilder
						.charAt(globalBuilder.length() - 1) == '\r'))
			return true;
		if (globalBuilder.toString().trim().equals("")
				&& curTextStr.toString().trim().equals(""))
			return true;
		return globalBuilder.length() == 0 && curTextStr.length() == 0;
	}
	
	protected void insertNewLineWithAfterListCheck()
	{
		if (!checkEolPresence() || isAfterSpecialString())
			endOfLineReached();
	}

	protected void insertNewLineIfNeeded() {
		if (!checkEolPresence())
			endOfLineReached();
	}

	protected boolean isAfterSpecialString()
	{
		if (lineBullets.size() > 0 && lineBullets.get(lineBullets.size() - 1) > BulletFactory.NONE_LIST_CONST)
			return true;
		if (partitions.size() > 0)
		{
			final BasePartition partition = partitions.get(partitions.size() - 1);
			if (partition instanceof RegionPartition)
				return true;
		}
		return false;
	}

	protected BasePartition getNewFontPartition() {
		// String addAfterPartitionStr = ""; // used for adding some symbols
		// after
		// current partition
		int newOffset = 0;
		if (partitions.size() > 0)
			newOffset = partitions.get(partitions.size() - 1).getOffset()
					+ partitions.get(partitions.size() - 1).getLength();
		BasePartition newPartition;
		if (!curHref.equals("")) {
			/*
			 * if (curTextStr.length() > 0 &&
			 * !Character.isWhitespace(curTextStr.charAt(curTextStr .length() -
			 * 1))) addAfterPartitionStr = " ";
			 */
			if (curTextStr.toString().equals(curHref) && WikitextTokenProvider.isCamelCaseWord(curHref))
			{
				newPartition = new CamelCasePartition(document, newOffset, curTextStr.length());
				((CamelCasePartition)newPartition).setUrl(curHref); //We need this, because we can be disconnected from document when doing some preprocessing
				if (escapedLink)
					((CamelCasePartition)newPartition).setStyle(CamelCasePartition.ESCAPED);
			}
			else
				newPartition = new LinkPartition(document, newOffset, curTextStr
						.length());
				((LinkPartition) newPartition).setUrl(curHref);
			curHref = "";
			escapedLink = false;
		} else
			newPartition = new BasePartition(document, newOffset, curTextStr
					.length());
		//newPartition.setRefreshVisibleState(false); // Don't update anything;
		// Partition is still under
		// construction
		newPartition.setBold(isBold);
		newPartition.setItalic(isItalic);
		newPartition.setUnderlined(isUnderlined);
		newPartition.setStrikethrough(isStrikethrough);
		newPartition.setSub(isSubscript);
		newPartition.setSup(isSuperscript);
		newPartition.setStrikethrough(isStrikethrough);
		if (headerState != NONE_HEADER)
			newPartition.setFontDataName(getFontDataNameForState(headerState));
		String resStr = curTextStr.toString();
		final int gbLength = globalBuilder.length();
		if (gbLength > 0 && globalBuilder.charAt(gbLength - 1) == ' '
				&& resStr.length() > 0
				&& (resStr.charAt(0) == ' ' || resStr.charAt(0) == '\t'))
			resStr = resStr.substring(1);

		/*
		 * if (!trimWhiteSpaces && str.charAt(i) == '\n') endOfLineReached();
		 */

		globalBuilder.append(resStr);
		newPartition.setLength(resStr.length());
		// curTextStr = new StringBuilder(addAfterPartitionStr);
		curTextStr = new StringBuilder();
		return newPartition;
	}

	protected String getFontDataNameForState(int state) {
		if (state == IS_HEADER1)
			return IFontStyleManager.FONT_H1_NAME;
		if (state == IS_HEADER2)
			return IFontStyleManager.FONT_H2_NAME;
		if (state == IS_HEADER3)
			return IFontStyleManager.FONT_H3_NAME;
		if (state == IS_HEADER4)
			return IFontStyleManager.FONT_H4_NAME;
		if (state == IS_HEADER5)
			return IFontStyleManager.FONT_H5_NAME;
		if (state == IS_HEADER6)
			return IFontStyleManager.FONT_H6_NAME;
		return IFontStyleManager.NORMAL_FONT_NAME;
	}

	
	/**
	 * @return the numberedListStarts
	 */
	public HashMap<Integer, String> getNumberedListStarts()
	{
		return numberedListStarts;
	}

	protected void resetStyleFlags() {
		isBold = false;
		isItalic = false;
		isUnderlined = false;
		isStrikethrough = false;
	}

}
